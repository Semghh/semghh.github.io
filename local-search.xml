<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>修改三方jar依赖</title>
    <link href="/2025/08/10/2025-08-10-modify-3party-jar/"/>
    <url>/2025/08/10/2025-08-10-modify-3party-jar/</url>
    
    <content type="html"><![CDATA[<p>紧接着上篇排查性能内鬼， 我们发现mp的数据权限拦截器默认拦截全部接口，使用<code>InterceptorIgnore</code>注解关闭指定接口。</p><p>我们对它的默认表现不满意，期望默认全部接口关闭，指定接口开启。</p><p>这篇笔记目标：优雅、简单的修改三方jar的依赖，更改其默认表现。</p><blockquote><p>一个可行的方法是 ： 将源码down下来自行修改、编译、打包。</p></blockquote><p>我这里只是一个小改动，mp项目使用的是gradle管理，不幸的是我对它并不熟悉。</p><p>因此换了一种方式实现。</p><span id="more"></span><h1 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h1><p>在DataPermissionInterceptor 中可以看到 ，判定是否需要数据权限解析借助工具类<code>InterceptorIgnoreHelper</code></p><p><img src="/image/2025-08-10-modify-3party-jar.assets/image-20250812111059917.png" alt="image-20250812111059917"></p><p>一路跟进，当接口方法没有任何声明的时候，该方法返回false。也就是 “不忽略”。 因此默认全部接口开启数据权限分析，基于项目不同会极大拖累接口响应，甚至部分数据库的特殊语法可能导致解析失败报错。</p><p><img src="/image/2025-08-10-modify-3party-jar.assets/image-20250812111502725.png" alt="image-20250812111502725"></p><p>到这里思路已经很明确，我们只需要将false改为true即可。</p><h1 id="2-怎么做？"><a href="#2-怎么做？" class="headerlink" title="2. 怎么做？"></a>2. 怎么做？</h1><h2 id="配置maven-dependency-plugin-插件"><a href="#配置maven-dependency-plugin-插件" class="headerlink" title="配置maven-dependency-plugin 插件"></a>配置maven-dependency-plugin 插件</h2><p>通过 <code>maven-dependency-plugin</code> 插件的 unpack 目标，我们可以将指定依赖的.class文件从jar包中解压到 <code>target/classes</code>中，便于我们后续打包使用。</p><p>配置如下图所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>unpack<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>unpack<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactItems</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">artifactItem</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">overWrite</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">overWrite</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">artifactItem</span>&gt;</span><br><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">artifactItems</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>关键点在于 unpack 目标绑定的阶段。</p><p>maven有3种生命周期 ，其中default生命周期中，有多个阶段，依次是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">phases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>validate<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>initialize<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-classes<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-test-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-test-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-test-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-test-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test-compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-test-classes<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>prepare-package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>pre-integration-test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>integration-test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>post-integration-test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>install<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>deploy<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">phases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们将unpack 绑定在 compile 之前任意的阶段都可以。</p><p>因为 unpack解压的文件会覆盖我们更改后compile的代码，因此unpack不能绑定在compile之后。</p><p>在configuration中配置好要解压的依赖，和指定目录：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactItems</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactItem</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 我这边测试 overwrite 为ture还是false都不影响覆盖规则。无论为什么值，都会覆盖.class。 唯一能控制的只有绑定的阶段。 后面的阶段覆盖前面阶段的产物。 不清楚为什么，doc中也没仔细解释overwrite到底是谁覆盖谁 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">overWrite</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">overWrite</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 输出文件夹为 target/classes --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">artifactItem</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">artifactItems</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h2><p>随后创建相同的包名，将原class文件拷贝过来，修改源码：</p><p><img src="/image/2025-08-10-modify-3party-jar.assets/image-20250812111832532.png" alt="image-20250812111832532"></p><h2 id="打包配置"><a href="#打包配置" class="headerlink" title="打包配置"></a>打包配置</h2><p>一般情况下直接打包，拷贝到原工程测试即可。</p><p>按照各位自己的需要，修改依赖的坐标。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.test<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>test-mybatis-plus-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure><p>排除原工程依赖 ,引入新依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>xxxxx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xxxx-module-infra-biz<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.test<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>test-mybatis-plus-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于 <code>mybatis-plus-core</code>这个依赖来说，将一部分有用的信息打包在了 MANIFEST中 ，经过原项目工程测试后如果没有打包则会报错。</p><p>因此我们需要配置额外的信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">addMavenDescriptor</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addMavenDescriptor</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">manifestEntries</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 根据原本mybatis-plus-core.jar中manifest的信息，添加如下配置 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Implementation-Title</span>&gt;</span>mybatis-plus-core<span class="hljs-tag">&lt;/<span class="hljs-name">Implementation-Title</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Implementation-Version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">Implementation-Version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Built-Gradle</span>&gt;</span>8.7<span class="hljs-tag">&lt;/<span class="hljs-name">Built-Gradle</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Bundle-DocURL</span>&gt;</span>https://baomidou.com/<span class="hljs-tag">&lt;/<span class="hljs-name">Bundle-DocURL</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Build-OS</span>&gt;</span>Windows 10<span class="hljs-tag">&lt;/<span class="hljs-name">Build-OS</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Built-By</span>&gt;</span>Administrator<span class="hljs-tag">&lt;/<span class="hljs-name">Built-By</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Build-Jdk</span>&gt;</span>21.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">Build-Jdk</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Build-Timestamp</span>&gt;</span>2024-10-23 22:49:54<span class="hljs-tag">&lt;/<span class="hljs-name">Build-Timestamp</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Automatic-Module-Name</span>&gt;</span>com.baomidou.mybatis.plus.core<span class="hljs-tag">&lt;/<span class="hljs-name">Automatic-Module-Name</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">manifestEntries</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h2><p>编码完成、打包配置完成以后， 直接使用 <code>mvn clean package</code>  即可完成绑定的unpack目标，以及compile覆盖。</p><p>在target中可以查看自己的构建产物。</p><p><img src="/image/2025-08-10-modify-3party-jar.assets/image-20250812113607294.png" alt="image-20250812113607294"></p><p>打开构建产物，找到对应class, 用IDEA反编译一下即可看到效果</p><p><img src="/image/2025-08-10-modify-3party-jar.assets/image-20250812113713077.png" alt="image-20250812113713077"></p><p>mp工程是由jdk21编译的，我们这里显示java17 并且返回true ，即可证明产物正确。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在原项目依赖中查找相关类：</p><p><img src="/image/2025-08-10-modify-3party-jar.assets/image-20250812113429399.png" alt="image-20250812113429399"></p><p>发现有且只有我们自己构建的依赖，即为正确。</p><p>并测试相关接口，行为表现符合预期，即可。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/2025/07/09/2025-07-08-mybatis-mapper-proxy/"/>
    <url>/2025/07/09/2025-07-08-mybatis-mapper-proxy/</url>
    
    <content type="html"><![CDATA[<p>最近在翻看Mybatis 、 Mp源码。 看到了 <code>@Mapper</code> 注解扫描， MapperProxy , MapperProxyFactory这些类。</p><p>梳理一下，@Mapper到底是怎么工作的。</p><span id="more"></span><h1 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h1><p>Mybatis 期望提供一种”便捷”、”所见即所得” 的方法，通过调用java方法的方式，来执行XML中的sql。</p><p>它最原始工作时的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">foo</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> ....; <span class="hljs-comment">//创建SqlSession</span><br>    <span class="hljs-type">MyMapper</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> SqlSession.getMapper(MyMapper.class);<span class="hljs-comment">//Mybatis返回给我们一个 MyMapper的java代理对象。</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> proxy.foo(<span class="hljs-string">&quot;semghh&quot;</span>);<span class="hljs-comment">//我们只需要调用  `MyMapper.foo()` 就可以找到对应的sql并调用。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Mybatis返回给我们一个 MyMapper的java代理对象。我们只需要调用  <code>MyMapper.foo()</code> 就可以找到对应的sql语句并调用。</p><h1 id="2-他是怎么做到的？"><a href="#2-他是怎么做到的？" class="headerlink" title="2. 他是怎么做到的？"></a>2. 他是怎么做到的？</h1><p>基于JDK动态代理。</p><p>相信很多人见过使用JDK动态代理做 AOP,但实际上动态代理还能作更多的东西。</p><p>我们一定都见过这样的aop代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello,name&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <br><span class="hljs-keyword">private</span>MyService origin;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//start</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> method.invoke(origin,args);<br>        <span class="hljs-comment">//end</span><br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">MyServiceImpl</span> <span class="hljs-variable">impl</span> <span class="hljs-operator">=</span> ...;<br><span class="hljs-type">MyService</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (MyService) Proxy.newProxyInstance(Main.class.getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;MyService.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceProxy</span>(impl));<br>o.hello(<span class="hljs-string">&quot;123&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>mybatis 是怎么把 Mapper.java  映射到 —&gt; XML sql 的呢？</p><p>实际上很简单 ： 传入impl ， 并在invoke实现一个映射转换即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> ....<span class="hljs-comment">//映射转换</span><br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-深入源码"><a href="#3-深入源码" class="headerlink" title="3.深入源码"></a>3.深入源码</h1><h2 id="3-1-获得Mapper-java-流程"><a href="#3-1-获得Mapper-java-流程" class="headerlink" title="3.1 获得Mapper.java 流程"></a>3.1 获得Mapper.java 流程</h2><p>从<code>SqlSession#getMapper()</code>中一路跟进 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DefaultSqlSession.java</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br><span class="hljs-keyword">return</span> configuration.getMapper(type, <span class="hljs-built_in">this</span>);<br>&#125;<br> <br><span class="hljs-comment">//Configuration.java</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;<br><span class="hljs-keyword">return</span> mapperRegistry.getMapper(type, sqlSession);<br>&#125;<br><br><br><span class="hljs-comment">//MapperRegistry</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;<br>    <span class="hljs-comment">//先获得代理工厂</span><br>  <span class="hljs-keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);<br>  <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is not known to the MapperRegistry.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//代理工厂创建一个新代理对象。 用的是SqlSession创建</span><br>    <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mapper代理工厂是哪里创建的？  </p><blockquote><p>mybatis扫描@Mapper ，并为每一个Mapper.java 创建 MapperProxyFactory 对象。 存放到knownMappers(ConcurrentHashMap)中。</p></blockquote><h2 id="3-2-创建proxy过程详解"><a href="#3-2-创建proxy过程详解" class="headerlink" title="3.2 创建proxy过程详解"></a>3.2 创建proxy过程详解</h2><p>所有的MapperProxyFactory对象都会存储到  MapperRegistry对象中。</p><p>MapperProxyFactory （Mapper代理工厂） 存储了代理的原始 Mapper.java 引用 （mapperInterface）</p><p>随后给代理方法做了一层缓存，存储到 ConcurrentHashMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;T&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Method, MapperMethodInvoker&gt; methodCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperProxyFactory</span><span class="hljs-params">(Class&lt;T&gt; mapperInterface)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Class&lt;T&gt; <span class="hljs-title function_">getMapperInterface</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> mapperInterface;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Map&lt;Method, MapperMethodInvoker&gt; <span class="hljs-title function_">getMethodCache</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> methodCache;<br>  &#125;<br><br>    <span class="hljs-comment">//JDK动态代理</span><br>  <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>  <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;<br>    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);<br>  &#125;<br><br>    <span class="hljs-comment">//先创建了一个 MapperProxy</span><br>  <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> &#123;<br>    <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);<br>    <span class="hljs-keyword">return</span> newInstance(mapperProxy);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MapperMethodInvoker"><a href="#MapperMethodInvoker" class="headerlink" title="MapperMethodInvoker"></a>MapperMethodInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MapperProxy.java 内部接口</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MapperMethodInvoker</span> &#123;<br>  Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="hljs-keyword">throws</span> Throwable;<br>   <span class="hljs-comment">//比 InvocationHandler.invoke多了一个SqlSession参数</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PlainMethodInvoker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MapperMethodInvoker</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MapperMethod mapperMethod;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PlainMethodInvoker</span><span class="hljs-params">(MapperMethod mapperMethod)</span> &#123;<br>      <span class="hljs-built_in">this</span>.mapperMethod = mapperMethod;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>      <span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);<br>    &#125;<br>  &#125;<br><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMethodInvoker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MapperMethodInvoker</span> &#123;<br>      <span class="hljs-comment">//jdk的方法句柄</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodHandle methodHandle;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultMethodInvoker</span><span class="hljs-params">(MethodHandle methodHandle)</span> &#123;<br>      <span class="hljs-built_in">this</span>.methodHandle = methodHandle;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//绑定了第一个参数，为创建出来的代理对象。 </span><br>      <span class="hljs-keyword">return</span> methodHandle.bindTo(proxy).invokeWithArguments(args);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到 使用了方法句柄 ，它要比一般的反射调用方法快。  还做了jdk8&#x2F;9的兼容。</p><p>对于非deafult方法，将使用PlainMethodInvoker调用。</p><p>对于default方法，将使用DefaultMethodInvoker调用。</p><h3 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h3><p>实现了 InvocationHandler ,  是整个代理过程的核心 ， 为Mapper.java中的每一个方法做了缓存。</p><p>解析、生成对应的  MethodInvoker。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;<br>      <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>    &#125;<br>      <span class="hljs-comment">//缓存调用</span><br>    <span class="hljs-keyword">return</span> cachedInvoker(method).invoke(proxy, method, args, sqlSession);<br>  &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>    <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(t);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> MapperMethodInvoker <span class="hljs-title function_">cachedInvoker</span><span class="hljs-params">(Method method)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> MapUtil.computeIfAbsent(methodCache, method, m -&gt; &#123;<br>      <span class="hljs-keyword">if</span> (!m.isDefault()) &#123;<br>          <span class="hljs-comment">//非default方法直接创建 PlainMethodInvoker并存放到map中</span><br>          <span class="hljs-comment">//可以看到,这里创建了一个类： MapperMethod, 它在创建的过程中完成了解析操作。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PlainMethodInvoker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperMethod</span>(mapperInterface, method, sqlSession.getConfiguration()));<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (privateLookupInMethod == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMethodInvoker</span>(getMethodHandleJava8(method));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMethodInvoker</span>(getMethodHandleJava9(method));<br>      &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InstantiationException | InvocationTargetException<br>          | NoSuchMethodException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>      &#125;<br>    &#125;);<br>  &#125; <span class="hljs-keyword">catch</span> (RuntimeException re) &#123;<br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> re.getCause();<br>    <span class="hljs-keyword">throw</span> cause == <span class="hljs-literal">null</span> ? re : cause;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建SqlCommand-方法签名"><a href="#创建SqlCommand-方法签名" class="headerlink" title="创建SqlCommand &amp; 方法签名"></a>创建SqlCommand &amp; 方法签名</h3><p>在创建 MethodInvocker的时候，new了一个 MapperMethod ，在MapperMethod的构造器中，解析并根据 statementId匹配了MappedStatement 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">MapperMethod</span><span class="hljs-params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> &#123;<br>    <span class="hljs-comment">//创建 SqlCommand 。 sqlcommand的从MappedStatement中取出了sql执行类型(select ,update ,insert,delete)</span><br>    <span class="hljs-comment">//根据sql执行类型做不同的操作。</span><br>    <span class="hljs-built_in">this</span>.command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlCommand</span>(config, mapperInterface, method);<br>    <span class="hljs-built_in">this</span>.method = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodSignature</span>(config, mapperInterface, method);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MapperMethod.java</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SqlCommand</span><span class="hljs-params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>      <span class="hljs-keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();<br>      <span class="hljs-comment">//解析映射语句，并从Configuration中取出对应的 MappedStatement （映射语句）。</span><br>      <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration);<br>      <span class="hljs-keyword">if</span> (ms == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (method.getAnnotation(Flush.class) == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<br>              <span class="hljs-string">&quot;Invalid bound statement (not found): &quot;</span> + mapperInterface.getName() + <span class="hljs-string">&quot;.&quot;</span> + methodName);<br>        &#125;<br>        name = <span class="hljs-literal">null</span>;<br>        type = SqlCommandType.FLUSH;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        name = ms.getId(); <span class="hljs-comment">//设置一下 name =  MappedStatemet.id</span><br>        type = ms.getSqlCommandType(); <span class="hljs-comment">//设置一下sql命令的类型</span><br>        <span class="hljs-keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Unknown execution method for: &quot;</span> + name);<br>        &#125;<br>      &#125;<br>    &#125;<br><br><br><br><span class="hljs-comment">//从Configuration中，取出  Mapper.java对应的 MappedStatement 映射语句。</span><br><span class="hljs-keyword">private</span> MappedStatement <span class="hljs-title function_">resolveMappedStatement</span><span class="hljs-params">(Class&lt;?&gt; mapperInterface, </span><br><span class="hljs-params">                                               String methodName, </span><br><span class="hljs-params">                                               Class&lt;?&gt; declaringClass,</span><br><span class="hljs-params">                                               Configuration configuration)</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">statementId</span> <span class="hljs-operator">=</span> mapperInterface.getName() + <span class="hljs-string">&quot;.&quot;</span> + methodName;<br>      <span class="hljs-keyword">if</span> (configuration.hasStatement(statementId)) &#123;<br>        <span class="hljs-keyword">return</span> configuration.getMappedStatement(statementId);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;<br>        <span class="hljs-keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;<br>          <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> resolveMappedStatement(superInterface, methodName, declaringClass, configuration);<br>          <span class="hljs-keyword">if</span> (ms != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ms;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>同样的，MapperMethod 构造器中也创建了方法签名，它是做什么的？</p><p> 方法签名记录了：  </p><ul><li>返回值特点： 是否集合。 是否Map , 是否void 是否Cursor ,是否Optional  （对于这些特点可以进行返回值特殊处理）</li><li>返回值类型：<code>Class&lt;?&gt;</code></li><li>参数命名解析器</li></ul>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次使用火焰图排查性能问题的经验</title>
    <link href="/2025/06/11/2025-06-11-arthas-exprience/"/>
    <url>/2025/06/11/2025-06-11-arthas-exprience/</url>
    
    <content type="html"><![CDATA[<p>最近正在给公司一个非常老的单体项目升级到微服务。</p><p>在测试过程中、发现迁移过来的接口慢的不正常。使用火焰图找到了这个性能内鬼。</p><span id="more"></span><h1 id="1-排查过程"><a href="#1-排查过程" class="headerlink" title="1. 排查过程"></a>1. 排查过程</h1><p>迁移的原始接口响应时间为 300ms ，迁移过来以后测试结果为10s+ ，这显然不正常。</p><h2 id="防火墙http包分析是内鬼吗？"><a href="#防火墙http包分析是内鬼吗？" class="headerlink" title="防火墙http包分析是内鬼吗？"></a>防火墙http包分析是内鬼吗？</h2><p>由于原接口方法逻辑未做修改，并且由于存在先例，最先想到的是公司服务器入口防火墙是内鬼。</p><p>怀疑是防火墙做了http包分析过慢导致。</p><p>这里使用  tcpdump分别对防火墙的入栈和出栈两侧抓包分析，发现并不是防火墙的问题。</p><h2 id="arthas-trace"><a href="#arthas-trace" class="headerlink" title="arthas trace"></a>arthas trace</h2><p>随后用 arthas trace 对相关方法追踪了一下，发现是数据交换的mapper层方法非常慢，消耗了绝大部分时间。</p><p>所以排查范围从网络链路缩小到 app内。</p><p>虽然缩小到app内，但还是很迷惑，原方法逻辑并没有修改，且响应时间也很稳定。</p><p>移植过来以后怎么会慢这么多，事已至此打一张火焰图看看，cpu到底消耗在哪里了。</p><h2 id="分析火焰图"><a href="#分析火焰图" class="headerlink" title="分析火焰图"></a>分析火焰图</h2><p>arthas 集成了async-profiler 直接使用 <code>profiler start/stop</code>  就可以生成火焰图：</p><p><img src="/image/2025-06-11-arthas-exprience.assets/image-20250612163431808.png" alt="image-20250612163431808"></p><p>通过火焰图发现85%的时间都消耗在了 com.fhs.trans.utils包下的方法。</p><p>随机查了一下，发现是一个名为 easy-trans的插件， 功能是给VO做字段翻译转换的。</p><p>然后简单的debug了一下这个方法，发现它在做转换的时候会递归遍历所有 vo的所有属性。如果属性是pojo那么还会遍历这个pojo的所有属性。</p><p>恰巧我这个接口返回的数据量很大、属性也是多级的、就导致明明是内存操作也慢到10s级别。</p><p>把这个插件按照接口忽略以后，响应时间恢复正常了。</p><h2 id="还有内鬼？"><a href="#还有内鬼？" class="headerlink" title="还有内鬼？"></a>还有内鬼？</h2><p>本以为事情到此就告一段落了，再调试后续接口时又发现新的问题。</p><p>部分ms级接口会不稳定的下降到s级别 。</p><p>于是再次打了一张火焰图：</p><p><img src="/image/2025-06-11-arthas-exprience.assets/image-20250612170511635.png" alt="image-20250612170511635"></p><p>发现在cpu调用中，JIT编译器退优化竟然占总采样的62%。</p><p>幸运的是，迁移项目的jdk为17, 已经拥有JFR功能，并且问题还算容易复现。</p><p>于是用jfr监听了一段接口调用的过程， 看看到底是什么东西在退优化。</p><h2 id="抓了一个内鬼但不是主因"><a href="#抓了一个内鬼但不是主因" class="headerlink" title="抓了一个内鬼但不是主因"></a>抓了一个内鬼但不是主因</h2><p>在监听期间，一共有8个退优化事件，排除jdk本身的，只剩一个 jdbc 驱动的问题。</p><p>是Druid连接池在初始化数据源时调用的方法，退优化的原因是  unstable_if （分支预测失败）。</p><p>查了一下分支预测失败的原因有很多 （if过多等）。</p><p><img src="/image/2025-06-11-arthas-exprience.assets/image-20250612171132115.png" alt="image-20250612171132115"></p><p>随后准备查看项目的mysql驱动依赖，进方法看看到底是怎么回事。直接让我逮到了！</p><p>项目引入了一个比较新版本的mysql启动，不是常用的<code> 8.0.33</code></p><p>随后将驱动降成常见版本，又打了一个jfr，退优化果然没了。</p><p>但接口缓慢问题依然存在。</p><h2 id="没什么办法，接着看火焰图吧"><a href="#没什么办法，接着看火焰图吧" class="headerlink" title="没什么办法，接着看火焰图吧"></a>没什么办法，接着看火焰图吧</h2><p>因为火焰图采样是对所有cpu同时采样，并且退优化这个问题不一定直接作用在接口调用栈上。</p><p>因此这次我直接在业务方法调用栈上找，看看能否有一些收获。</p><p><img src="/image/2025-06-11-arthas-exprience.assets/image-20250612171957912.png" alt="image-20250612171957912"></p><h2 id="逮到！"><a href="#逮到！" class="headerlink" title="逮到！"></a>逮到！</h2><p>一般来说是不会怀疑驱动器的，但是你这个parser占用了这么久到底是解析什么？</p><p><img src="/image/2025-06-11-arthas-exprience.assets/image-20250612172049406.png" alt="image-20250612172049406"></p><p>还是同样的思路，正准备看看这个解析方法到底做了什么。 </p><p>欸，这clickhouse的驱动依赖怎么这么陌生啊， 怎么还是apache开头的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        &lt;dependency&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;groupId&gt;org.apache.pulsar&lt;/groupId&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;artifactId&gt;pulsar-io-jdbc-clickhouse&lt;/artifactId&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;/dependency&gt;--&gt;</span><br></code></pre></td></tr></table></figure><p>于是马上和原项目的驱动依赖对比了一下，发现这个依赖是同事无意间引入的。</p><p>将所有ck相关依赖替换与原项目一致，解决问题！</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优化</tag>
      
      <tag>JFR</tag>
      
      <tag>Arthas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子性修改数组元素引发的思考</title>
    <link href="/2025/02/18/2025-02-13-array-atomic-update/"/>
    <url>/2025/02/18/2025-02-13-array-atomic-update/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="1-赋值操作-原子性"><a href="#1-赋值操作-原子性" class="headerlink" title="1.  赋值操作-原子性"></a>1.  赋值操作-原子性</h1><p>64位虚拟机的引用是64bit或32bit(开启指针压缩，堆内存无法超过32GB)，因此一次赋值操作(<code>=</code>)是原子的。</p><h1 id="2-“可见性”"><a href="#2-“可见性”" class="headerlink" title="2.  “可见性”"></a>2.  “可见性”</h1><p>原子操作、和可见性经常被同时提及。</p><h2 id="2-1-无需保证可见性的场景"><a href="#2-1-无需保证可见性的场景" class="headerlink" title="2.1 无需保证可见性的场景"></a>2.1 无需保证可见性的场景</h2><p>但两者(原子性，可见性)是完全不同的语义，并且大多数场景下，我们只需要保证update操作的原子性，而不需要保证严格的“及时”。</p><blockquote><p>所谓严格的及时指 “可见性保证”。 </p><p>修改者改变了某个值，但读取者无需立即知道新的值（也就是，在业务上使用稍过期的值并没有什么问题）。此时我们可以不使用volatile(也就是无需保证可见性)</p></blockquote><h2 id="2-2-需要保证可见性的场景"><a href="#2-2-需要保证可见性的场景" class="headerlink" title="2.2 需要保证可见性的场景"></a>2.2 需要保证可见性的场景</h2><p>假设，我们有一个long[]数组， 我们通过Unsafe可以很轻易地做到 <code>atomic + volatie</code>的修改其中一个long元素。</p><p>如果业务有如下要求， index为N的元素和 index为N-1的元素有关联，两者共同组成了一种业务语义。</p><p>并且这个long[]数组整体是共享的，那么我们必须要保证元素的可见性。</p><p>因为我们不可能拿新的index&#x3D;N的元素和旧的index&#x3D;N-1的元素共同表达业务语义。</p><blockquote><p>这和32bit虚拟机无法保证 long类型的赋值操作是”原子性”的原因类似——后32bit和前32bit是一个整体，我们不应当看见一个 “牛头马尾”。而是一个完整的牛或马。</p></blockquote><h3 id="2-2-1-如何解决上述场景"><a href="#2-2-1-如何解决上述场景" class="headerlink" title="2.2.1 如何解决上述场景"></a>2.2.1 如何解决上述场景</h3><p>转换一下思维，若 long1和long2组成一个整体，我们把它定义为一个新的ClassA。</p><p>将long[] 改为 A[]，然后” 原子性” 且 “volatile”  的修改元素。</p><blockquote><p>缺点是引入了一个新的Class，带来了额外开销。</p></blockquote><h2 id="2-3-happen-before"><a href="#2-3-happen-before" class="headerlink" title="2.3  happen-before"></a>2.3  happen-before</h2><p>“可见性” 只是一种通俗的表达。 在java规范中，只有  happen-before 的定义。</p><p>JVM通过屏障来实现 happen-before语义。而对于不同的cpu平台，屏障的实现也是不同。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定时器的实现</title>
    <link href="/2024/12/24/2025-01-26-timer/"/>
    <url>/2024/12/24/2025-01-26-timer/</url>
    
    <content type="html"><![CDATA[<p>JDK中集成了简单的定时任务池(ScheduledThreadPool)提供了最简单的任务调度。</p><p>Netty中则给出了另一种任务池的实现(Timer)。</p><span id="more"></span><h1 id="1-Timer"><a href="#1-Timer" class="headerlink" title="1. Timer"></a>1. Timer</h1><p>定时器。也是调度池的核心（为每一个任务设置一个定时器，当定时过期以后就触发任务执行。）</p><p>在jdk中 DougLea使用了以 “最小堆”为数据结构定时器来实现了  ScheduledThreadPoolExecutor 。</p><p>而Netty中，使用了 George Varghese and Tony Lauck 论文提供的Hash结构的定时器。</p><p>这两种各有什么优劣？</p><h2 id="1-1-定时器实现方式"><a href="#1-1-定时器实现方式" class="headerlink" title="1.1 定时器实现方式"></a>1.1 定时器实现方式</h2><p>首先定时器需要模拟一个时间流逝的过程(本质是模拟task过期，然后执行)。</p><p>一般来说有2种方式模拟：</p><ul><li><p>直接法 ：    拟定一个时间尺度interval （比如50 ms） 把它当作时钟tick的最小单位。每经过一个tick ，时钟就向后滚动interval，然后减少所有Timer的生命周期，若Timer过期，则执行task。</p></li><li><p>顺序队列： 所有的Timer都需要按照过期时间由近到远排列为一个list。list的头节点是最近过期的Timer。</p><p><img src="/image/2025-01-26-timer.assets/image-20250127114450101.png" alt="image-20250127114450101"></p></li></ul><p>两种方案的对比：</p><p><img src="/image/2025-01-26-timer.assets/image-20250127114556050.png" alt="image-20250127114556050"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.lenshood.dev/2021/01/27/java-varhandle/#opaque">https://www.lenshood.dev/2021/01/27/java-varhandle/#opaque</a></p><p><a href="https://gee.cs.oswego.edu/dl/html/j9mm.html#summarysec">https://gee.cs.oswego.edu/dl/html/j9mm.html#summarysec</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jdk9 内存顺序模型</title>
    <link href="/2024/12/24/2024-12-25-memory-model/"/>
    <url>/2024/12/24/2024-12-25-memory-model/</url>
    
    <content type="html"><![CDATA[<p>本文谈一下对  Java Memeory Mode 的理解。</p><span id="more"></span><h1 id="1-Java-Memory-Modes"><a href="#1-Java-Memory-Modes" class="headerlink" title="1. Java Memory Modes"></a>1. Java Memory Modes</h1><p>术语Java Memeory Mode (在jdk9中被 doug lea 提及) ，这个术语通常用于描述 java 并发模型。</p><p>在jdk9中，提供了一套 VarHandle API ， 为高级的Java程序员提供了一种控制并发的方式。</p><blockquote><p>提供了一些控制原语。  也可以认为是一些“控制保证”。 程序员可以利用这些”保证“来编写出符合业务逻辑的，安全的，效率的工具。</p></blockquote><h2 id="1-1-Varhandle-API-的介绍"><a href="#1-1-Varhandle-API-的介绍" class="headerlink" title="1.1  Varhandle API 的介绍"></a>1.1  Varhandle API 的介绍</h2><p>我们需要使用 <code>MethodHandles.lookup()</code> 来获得 VarHandle变量。</p><p>&#x2F;&#x2F;TODO</p><h2 id="1-2-并发的背景"><a href="#1-2-并发的背景" class="headerlink" title="1.2  并发的背景"></a>1.2  并发的背景</h2><p>“并发”总是会出现一种令人意想不到的现象，它总是难以捕捉，例如经典的 <code>i++</code> 问题。</p><p>导致这种现象的可能原因有：</p><h3 id="任务并行"><a href="#任务并行" class="headerlink" title="任务并行"></a>任务并行</h3><ul><li>任务并行。  对于单核处理器来说，两个线程分别执行操作A和B。 那么只有简单的A先于B 或 B先于A 。但是对于多核来说，两个操作可能是无序的（或许是同时进行）</li></ul><h3 id="内存并行"><a href="#内存并行" class="headerlink" title="内存并行"></a>内存并行</h3><ul><li><p>内存并行。除了任务并行(多核并行)以外，内存并行仍然可能导致问题。内存可能同时被多个设备代理(通常是缓存)， 变量不是由”唯一”的物理设备表示（这将会带来强制刷新到内存、失效缓存行等问题）。</p><p>除此以外，处理器一次性能够操作内存的宽度也会引起问题(例如32位cpu读取long类型)，他们不总是原子的操作。</p></li></ul><h3 id="指令并行"><a href="#指令并行" class="headerlink" title="指令并行"></a>指令并行</h3><ul><li>指令并行。  （cpu的流水线作业）cpu包含了多个部件，多个部件是协同工作的。cpu指令总是以叠加的方式处理指令。 因此同一时间可能会处理多个cpu指令。</li></ul><h2 id="1-3-更多的模式"><a href="#1-3-更多的模式" class="headerlink" title="1.3 更多的模式"></a>1.3 更多的模式</h2><p>处理上述 “并行”的概念和技术逐渐成熟， 相同的方法经常出现在不同的编程语言中。</p><p>“没有银弹！”   在众多的规则和模型中，没有一个对所有程序中所有代码都有意义。</p><p>多核的经验表明，需要更多的模式(mode)来处理常见的并发编码问题。如果没有他们，一些程序员可能会过渡的使用 同步代码，这会让程序变得更慢。</p><p>而一些程序员通过使用非标准操作，在特定的JVM和处理上 绕过限制实现了这些行为，虽然可行但会导致移植性较差。</p><p>新的 Memeory Order Mode （内存顺序模型），具有积累效果（约束越来越强，性能则递减）。</p><p>从最弱到最强：</p><p>plain  -&gt; Opaque -&gt; Release&#x2F;Acquire -&gt;  Volatile</p><p>其中plain和 Volatile 与jdk9之前兼容。</p><h3 id="plain"><a href="#plain" class="headerlink" title="plain"></a>plain</h3><p>最简单的 <code>=</code>操作，对没有volatile修饰的变量操作，就是plain，可能是 plain read  或 plain write。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">plainRead</span><span class="hljs-params">(Foo f)</span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> f.value; <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">plainWrite</span><span class="hljs-params">(Foo f)</span>&#123;<br>    f.value = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>plain 没有任何额外的语义，没有任何额外的保证。</p><p>JVM 规范保证，在单线程内，无论指令如何重排，总是保证plain的直观表现：</p><p>例如 <code>  d = (a + b) * (c + b);</code></p><p>所有的load都可能提前启动 , 指令示意图：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">load a, <span class="hljs-built_in">r1</span> | load b, <span class="hljs-built_in">r2</span> | load c, <span class="hljs-built_in">r4</span> | load b, <span class="hljs-built_in">r5</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">r3</span> | <span class="hljs-keyword">add</span> <span class="hljs-built_in">r4</span>, <span class="hljs-built_in">r5</span>, <span class="hljs-built_in">r6</span><br><span class="hljs-keyword">mul</span> <span class="hljs-built_in">r3</span>, <span class="hljs-built_in">r6</span>, <span class="hljs-built_in">r7</span><br>store <span class="hljs-built_in">r7</span>, d<br></code></pre></td></tr></table></figure><p>但最终仍会表现得正确。</p><h3 id="Opaque-Mode"><a href="#Opaque-Mode" class="headerlink" title="Opaque  Mode"></a>Opaque  Mode</h3><p>ValueHandle 提供了2个api <code>getOpaque()</code>  &#x2F; <code>setOpaque()</code></p><p>比Plain 模式添加了额外的约束， 这些约束提供了 “线程间访问” 中 “变量的”最小感知”。</p><p>当使用Opaque（或更强的模式）时，提供保证：</p><ul><li><p>一致性： 保证了变量严格的读写顺序。保证了 依赖于先读然后写的操作， 或  写操作后再读的一致性。</p><p>换句话说就是不会破坏  RMW（读-修改-写）的关系。</p></li><li><p>持续：  写操作只保证最终可见。</p><p>换句话说，不保证其他线程立即可见。但最终一定会可见。</p></li><li><p>bitwise 原子性 :  如果使用 Opaque (或更强的模式)访问，读取所有的数据类型，包括(long ,double) 在bitwise尺度上都是原子性的（保证一次完整读取所有bit），不会混合读取多次并发写入的bit（不会出现前一半儿bit是A操作写入，后一半儿bit是B写入，导致数据组合在一起是无意义的）。</p></li></ul><h3 id="release-acqiure-模式"><a href="#release-acqiure-模式" class="headerlink" title="release&#x2F;acqiure 模式"></a>release&#x2F;acqiure 模式</h3><p>通过 <code>VarHandle.setRelease()</code>  <code>VarHandle.getAcquire()</code> api来实现 release&#x2F;acquire 模式。并且比Opaque提供了积累(拥有Opaque的全部约束保证)的约束：</p><ul><li><p>在线程T内， 如果一个访问操作A  源码上在 Release(或更强的模型)写操作W 之前。那么在本地线程内，A操作在W之前。</p></li><li><p>在线程T内，如果 acquire(或更强的模式)读操作R 在源码上在访问操作A之前。 那么acquire R操作先发生，A访问后发生。</p></li></ul><p>RA(release&#x2F;acquire)模式是因果一致性系统的主要思想。 因果性在大多数的通信形式上是必不可少的。例如，如果我做好了晚饭，我告诉你已经做好了晚饭，你听到了我的声音，那么你可以确定晚餐一定存在。 在听到ready 时，你一定能访问到正确的dinner </p><p>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> ready; <span class="hljs-comment">// 初始化的值是0 ,使用 VarHandle REDAY 引用该变量</span><br><span class="hljs-type">int</span> dinner;         <span class="hljs-comment">// mode does not matter here  </span><br><br><br>Thread <span class="hljs-number">1</span>                   |  Thread <span class="hljs-number">2</span> <br>dinner = <span class="hljs-number">17</span>;               |  <span class="hljs-keyword">if</span> (READY.<span class="hljs-built_in">getAcquire</span>(<span class="hljs-keyword">this</span>) == <span class="hljs-number">1</span>)  <span class="hljs-comment">//如果看到了 ready =1</span><br>READY.<span class="hljs-built_in">setRelease</span>(<span class="hljs-keyword">this</span>, <span class="hljs-number">1</span>); |    <span class="hljs-type">int</span> d = dinner; <span class="hljs-comment">// 那么一定保证看到dinner=17</span><br></code></pre></td></tr></table></figure><p>如果看到了Release操作做出的改变，那么在Release之前的编码的操作一定执行完毕。</p><p>在生产者消费者设计、消息传递设计中，需要 RA模式的保证。</p><h4 id="RA栅栏"><a href="#RA栅栏" class="headerlink" title="RA栅栏"></a>RA栅栏</h4><p>你可以使用api风格更明确的 RA模式：</p><p>先调用 <code>VarHandle.releaseFence()</code>  ，然后使用 <code>VarHandle.setOpaque()</code>来代替<code>setRelease()</code> 。如果你的变量是  bitwise原子性的，那么甚至可以用 plain 来代替。</p><p>同样的，可以使用 <code>VarHandle.acquireFence()</code> 插入acquire屏障，然后逐步用opaque、plain 代替acquire</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Thread 1:</span><br><br>dinner = <span class="hljs-number">17</span>;<br>VarHandle.releaseFence();<span class="hljs-comment">//R屏障</span><br>ready = <span class="hljs-number">1</span>;<br><br>Thread <span class="hljs-number">2</span>:<br>VarHandle.acquireFence();<br><span class="hljs-keyword">if</span>(ready==<span class="hljs-number">1</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> dinner;  <span class="hljs-comment">//此处一定能看到dinner=17</span><br></code></pre></td></tr></table></figure><p>但是<code> releaseFence()</code>  可能比 <code>setRelease()</code> 提供更多的额外约束 ： </p><p>releaseFence是一个栅栏，将前面的所有访问和 后面的所有写入分开， <code> releaseFence()</code> 保证Fence之前的所有访问都完成，再执行后续的写入操作。</p><h4 id="提供一个简单的验证程序"><a href="#提供一个简单的验证程序" class="headerlink" title="提供一个简单的验证程序"></a>提供一个简单的验证程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainForFences</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> ready;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> dinner;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> VarHandle varHandle;<br>    <span class="hljs-keyword">static</span> &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            varHandle = MethodHandles.lookup()<br>                    .findVarHandle(MainForFences.class,<span class="hljs-string">&quot;ready&quot;</span>,<span class="hljs-type">int</span>.class);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InterruptedException &#123;<br><br><br>        <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">10000</span>==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(a);<br>                System.out.println(b);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> callable();<br>            <span class="hljs-keyword">if</span> (callable==<span class="hljs-number">0</span>) a++;<br>            <span class="hljs-keyword">if</span> (callable==<span class="hljs-number">19</span>) b++;<br><br>        &#125;<br>        System.out.println(a);<br>        System.out.println(b);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">callable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MainForFences</span> <span class="hljs-variable">mainForFences</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainForFences</span>();<br><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            mainForFences.dinner = <span class="hljs-number">19</span>;<br>            VarHandle.releaseFence();<br>            mainForFences.ready=<span class="hljs-number">1</span>;<br>        &#125;);<br><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                VarHandle.acquireFence();<br><br>                <span class="hljs-keyword">if</span> (mainForFences.ready == <span class="hljs-number">1</span>) &#123;<br>                    res.set(mainForFences.dinner);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br><br>        t1.join();<br>        t2.join();<br><br>        <span class="hljs-keyword">return</span> res.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.lenshood.dev/2021/01/27/java-varhandle/#opaque">https://www.lenshood.dev/2021/01/27/java-varhandle/#opaque</a></p><p><a href="https://gee.cs.oswego.edu/dl/html/j9mm.html#summarysec">https://gee.cs.oswego.edu/dl/html/j9mm.html#summarysec</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT中 broker如何实现QoS</title>
    <link href="/2024/12/24/2025-02-12-mqtt-qos/"/>
    <url>/2024/12/24/2025-02-12-mqtt-qos/</url>
    
    <content type="html"><![CDATA[<p>我们都知道MQTT中消息的QoS级别，它和我们业务需求的可靠性息息相关。</p><p>那么对于Qos消息，broker做了什么来保证”精确一次”&#x2F;“至少一次”&#x2F;“至多1次”语义的呢？</p><span id="more"></span><h1 id="1-MQTT"><a href="#1-MQTT" class="headerlink" title="1.  MQTT"></a>1.  MQTT</h1><p>MQTT 是物联网最常见的协议之一。它运行在TCP之上，因此可以认为是应用层协议。</p><p>MQTT不关心 TCP层做的事情，它只定义了 消息是怎样在通信双方传递的。</p><p>物联网&#x2F;弱网情况下，选择MQTT协议， 它的优势有：</p><ul><li>协议头足够小，开销低</li><li>提供了3种Qos级别，可以在弱网条件下，适应多种业务需求</li><li>使用broker解耦通信双方，足够简单。</li><li>可以扩展到上千万的设备</li><li>安全，支持TLS</li></ul><p>本文主要关心Qos和broker在Qos中都做了什么。</p><p>你需要理解的术语有：</p><ul><li>broker :  MQTT的服务器，完成消息的接收、路由工作。</li><li>client :  客户端。既是消息发送者，又可以是 消费者。  broker 和 client  是一组对立概念。</li></ul><blockquote><p>这张图能够帮你更好的理解 client 和 broker 。</p><p>broker 就是一组MQTT Server的实现。 message  producer 把消息推给broker 与 message consumer解耦</p><p><img src="/image/2025-02-12-mqtt-qos.assets/image-20250213102222600.png" alt="image-20250213102222600"></p></blockquote><ul><li>sender :  一次通信的消息发起者。</li><li>receiver : 一次通信的消息接收者。</li></ul><h1 id="2-Broker-如何达成QoS"><a href="#2-Broker-如何达成QoS" class="headerlink" title="2. Broker 如何达成QoS"></a>2. Broker 如何达成QoS</h1><p> Qos 有3个级别  <code>0,1,2</code> 他们的开销，依次提升但能提供更多的业务保证 ： </p><h2 id="Qos-0"><a href="#Qos-0" class="headerlink" title="Qos 0"></a>Qos 0</h2><p>Qos 0 ：至多一次。 </p><p>sender 发送 PUBLISH packet 并声明QoS为0。 broker接收到消息以后不做出任何回复。若此消息丢失，sender不知道并且sender 不会做任何重发。</p><p>因此，消息最多到达1次broker。</p><p>图示：</p><p><img src="/image/2025-02-12-mqtt-qos.assets/image-20250213102222600.png" alt="image-20250213102222600"></p><h2 id="Qos-1"><a href="#Qos-1" class="headerlink" title="Qos 1"></a>Qos 1</h2><p>Qos 1： 至少1次。</p><p><img src="/image/2025-02-12-mqtt-qos.assets/image-20250213102639040.png" alt="image-20250213102639040"></p><p>sender首先发送 PUBLISH QoS1 的数据包。 broker接收到packet以后，知道此次通信是QoS1，然后向 sender回复 PUBACK packet。</p><blockquote><p>注意，此时broker不会缓存任何 packet数据包。不会做重复校验处理</p></blockquote><p>若sender未在规定时间内收到 receiver的 PUBACK 数据包，那么它会尝试重新发送原始数据包，直到收到 PUBACK 为止。</p><p>broker在这个过程中不会缓存任何packet，因此收到一份数据包(可能是重传的)都会响应 PUBACK  。</p><p>所以 QoS 1 是消息至少1次(可能多次到达，消息可能重复)。</p><h2 id="Qos-2"><a href="#Qos-2" class="headerlink" title="Qos 2"></a>Qos 2</h2><p>Qos 2： 精确1次。</p><p><img src="/image/2025-02-12-mqtt-qos.assets/image-20250213103024860.png" alt="image-20250213103024860"></p><p>Sender 向 Broker发送 QoS为2的 PUBLISH ，broker收到以后， broker会缓存packetID，并响应 PUBREC。</p><p>若sender  未收到PUBREC,则重传原始数据包。 broker收到重复 packetID的数据包丢弃，并响应PUBREC。</p><p>若sender正常收到PUBREC，则向broker发送 PUBREL ， 只要 broker收到 PUBREL以后，就会释放所有保存的状态，并返回 PUBCOMP packet 。</p><blockquote><p>在 broker收到 PUBREL 且 完全处理消息之前， broker都必须保存原始的packet。</p></blockquote><p>若sender  收到 PUBCOMP packet 以后，则释放所有保存的状态， packetID 回收等待重新利用。</p><p>sender未收到 PUBCOMP ，则会重传 PUBREL。</p><p>broker必须保证响应每一次的  PUBREL，都回复 PUBCOMP</p><p>至此，QoS2结束。 QoS2保证了 Sender已经将原始packet传递到broker ，并且Sender已知 broker确实收到消息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.hivemq.com/static/ebooks/hivemq-ebook-mqtt-essentials.pdf">https://www.hivemq.com/static/ebooks/hivemq-ebook-mqtt-essentials.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mqtt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty中组件及源码</title>
    <link href="/2024/12/24/netty-pipeline/"/>
    <url>/2024/12/24/netty-pipeline/</url>
    
    <content type="html"><![CDATA[<p>关于Netty中重要的组件 EventLoop, Pipeline , Handler , FastThreadLocal ,ByteBuf ，Allocator等组件源码分析。</p><span id="more"></span><h1 id="1-组件"><a href="#1-组件" class="headerlink" title="1. 组件"></a>1. 组件</h1><h2 id="1-1-DefaultChannelPipeline-组件"><a href="#1-1-DefaultChannelPipeline-组件" class="headerlink" title="1.1   DefaultChannelPipeline  组件"></a>1.1   DefaultChannelPipeline  组件</h2><p>Pipeline是Netty异步处理的核心，开发者实现将Handler(处理回调)注册到Pipeline中。 Pipeline注册到EventLoop中，</p><p>当io.netty.channel.Channel监听到了IO事件以后，会将Message传播到 Pipeline中。</p><p>DefaultChannelPipeline是 ChannelPipeline的默认实现。</p><p>整个Pipeline就是责任链模式。</p><blockquote><p>责任链设计思路的核心就是：每个handler都处理自己份内的事儿，当前的handler处理消息完毕，event传递到下一个handler。</p><p>使用责任链值得注意的点： Handler的先后顺序有讲究，需要特别注意前后Handler对Message的传递情况。</p><p>Netty有入站、出站2种event区分。  “引用计数对象”的retain 和 release。</p></blockquote><h3 id="fireChannelRead-方法"><a href="#fireChannelRead-方法" class="headerlink" title="fireChannelRead() 方法"></a><code>fireChannelRead()</code> 方法</h3><p>Pipeline的<code>fireChannelRead()</code> 和  context 的<code>fireChannelRead()</code> 传递源头是不同的。</p><blockquote><p>pipeline 从head传播</p><p>context 从下一个handler开始传播</p></blockquote><p>每一个io.netty.channel.Channel都有独立的Pipeline。每一个Pipeline的Handler链都有 Head 和 Tail节点。</p><p>pipeline 从head传播:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DefaultChannelPipeline.java</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">fireChannelRead</span><span class="hljs-params">(Object msg)</span> &#123;<br>        <span class="hljs-comment">//传入了head节点。</span><br>        AbstractChannelHandlerContext.invokeChannelRead(head, msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>context 从下一个handler开始传播:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractChannelHandlerContext.java</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelHandlerContext <span class="hljs-title function_">fireChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object msg)</span> &#123;<br>        <span class="hljs-comment">//从下一个支持channel_read 事件的handler，然后开始传播</span><br>        <span class="hljs-comment">//findContextInbound是netty内部使用的,用于过滤 handler的</span><br>        <span class="hljs-comment">//每个handler可以设置自己支持的event callback。</span><br>        invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="DefaultChannelPipeline写出数据的流程"><a href="#DefaultChannelPipeline写出数据的流程" class="headerlink" title="DefaultChannelPipeline写出数据的流程"></a>DefaultChannelPipeline写出数据的流程</h3><p><code>channel.writeAndFlush()</code> 调用了<code>AbstractChannel.write(Object,boolean,ChannelPromise)</code>和 <code>AbstractChannel.flush()</code>两个方法。</p><blockquote><p><code>flush()</code> 方法做的操作就是将  ChannelOutboundBuffer内保存的消息标记输出，并调用 <code>AbstractChannel.flush0()</code>方法，向远程的socket写出数据。</p></blockquote><p>如果调用pipeline的write方法，消息将通过TailContext层层向上传播，直到HeadContext 统一写出为止。</p><p>下面是源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractChannelHandlerContext.java</span><br><span class="hljs-comment">//TailContext是  AbstractChannelHandlerContext  上下文的子类。因此writeAndFlush最后调用了这个write</span><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">writeAndFlush</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>    write(msg, <span class="hljs-literal">true</span>, promise);<span class="hljs-comment">//调用了自己的write()</span><br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, <span class="hljs-type">boolean</span> flush, ChannelPromise promise)</span> &#123;<br>        ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isNotValidPromise(promise, <span class="hljs-literal">true</span>)) &#123; <span class="hljs-comment">//如果promise不合法，就取消写入</span><br>                ReferenceCountUtil.release(msg);<br>                <span class="hljs-comment">// cancelled</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>            ReferenceCountUtil.release(msg);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br><span class="hljs-comment">//从 context链条中向前找，找到第一出站HandlerContext</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> findContextOutbound(flush ?<br>                (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> pipeline.touch(msg, next);<br>        <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>        <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>            <span class="hljs-keyword">if</span> (flush) &#123;<br>                next.invokeWriteAndFlush(m, promise);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                next.invokeWrite(m, promise);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">WriteTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> WriteTask.newInstance(next, m, promise, flush);<br>            <span class="hljs-keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;<br>                <span class="hljs-comment">// We failed to submit the WriteTask. We need to cancel it so we decrement the pending bytes</span><br>                <span class="hljs-comment">// and put it back in the Recycler for re-use later.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/8343.</span><br>                task.cancel();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeWriteAndFlush</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>        <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>            invokeWrite0(msg, promise);<br>            invokeFlush0();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            writeAndFlush(msg, promise);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeWrite</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>        <span class="hljs-keyword">if</span> (invokeHandler()) &#123; <span class="hljs-comment">//检测ChannelHandler. handlerAdded(ChannelHandlerContext)是否已经被调用。</span><br>            invokeWrite0(msg, promise);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            write(msg, promise);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeWrite0</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// DON&#x27;T CHANGE</span><br>            <span class="hljs-comment">// Duplex handlers implements both out/in interfaces causing a scalability issue</span><br>            <span class="hljs-comment">// see https://bugs.openjdk.org/browse/JDK-8180450</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> handler();<br>            <span class="hljs-keyword">final</span> DefaultChannelPipeline.<span class="hljs-type">HeadContext</span> <span class="hljs-variable">headContext</span> <span class="hljs-operator">=</span> pipeline.head;<br>            <span class="hljs-keyword">if</span> (handler == headContext) &#123;<br>                headContext.write(<span class="hljs-built_in">this</span>, msg, promise);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> ChannelDuplexHandler) &#123;<br>                ((ChannelDuplexHandler) handler).write(<span class="hljs-built_in">this</span>, msg, promise);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> ChannelOutboundHandlerAdapter) &#123;<br>                ((ChannelOutboundHandlerAdapter) handler).write(<span class="hljs-built_in">this</span>, msg, promise);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ((ChannelOutboundHandler) handler).write(<span class="hljs-built_in">this</span>, msg, promise);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            notifyOutboundHandlerException(t, promise);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="写出数据是否有线程安全问题？"><a href="#写出数据是否有线程安全问题？" class="headerlink" title="写出数据是否有线程安全问题？"></a>写出数据是否有线程安全问题？</h4><p><code>write()</code> 、<code>writeAndFlush()</code> 方法，都会将写出的消息(Object对象) 通过pipeline层层处理传递，最终交付给 HeadContext对象。</p><p>虽然每个ChannelHandler可能绑定了不同的 executor，但最终写出操作都由<code>HeadContext</code>来完成。 HeadContext对象由pipeline创建，它绑定的executor是reactor线程。因此不会出现线程安全问题。</p><h4 id="writeAndFlush比write多了什么？"><a href="#writeAndFlush比write多了什么？" class="headerlink" title="writeAndFlush比write多了什么？"></a><code>writeAndFlush</code>比<code>write</code>多了什么？</h4><p>AbstractChannel内拥有一个 Unsafe对象，它来完成数据的交换任务。</p><p>数据写出时，有一个缓冲区（ChannelOutboundBuffer），如果消息不flush的话，消息不会向socket发出。</p><p><code>write()</code>消息时，会把消息添加到ChannelOutboundBuffer， 当调用flush以后，会把buffer内所有消息都发射出去。</p><p>HeadContext 的<code>write()</code>方法由Netty的Unsafe接口写出数据。</p><p>Unsafe负责io.netty.channel.Channel中底层的IO操作。</p><p>Unsafe 有一个 ChannelOutboundBuffer对象，是channel写出数据的缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstructUnsafe的 write方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>            assertEventLoop();<br><span class="hljs-comment">//拿到了内部的ChannelOutboundBuffer缓冲区</span><br>            <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">outboundBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.outboundBuffer;<br>            <span class="hljs-keyword">if</span> (outboundBuffer == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// release message now to prevent resource-leak</span><br>                    ReferenceCountUtil.release(msg);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//如果ChannelOutboundBuffer是空，那么证明这个channel被关闭了。</span><br>                    <span class="hljs-comment">//所以设置ChannelPromise为失败。</span><br>                    <span class="hljs-comment">//如果ChannelOutboundBuffer不空，就处理剩余数据。将在flush0中处理。</span><br>                    safeSetFailure(promise,<br>                            newClosedChannelException(initialCloseCause, <span class="hljs-string">&quot;write(Object, ChannelPromise)&quot;</span>));<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> size;<br>            <span class="hljs-keyword">try</span> &#123;<br>                msg = filterOutboundMessage(msg);<br>                <span class="hljs-comment">//对消息大小进行评估，若无法评估返回&lt;0的int</span><br>                size = pipeline.estimatorHandle().size(msg);<br>                <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>) &#123;<br>                    size = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ReferenceCountUtil.release(msg);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    safeSetFailure(promise, t);<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><span class="hljs-comment">//只是将传入的message写入buffer中（而没有flush）。一旦消息完成写入以后，promise将会收到通知</span><br>            outboundBuffer.addMessage(msg, size, promise);<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ChannelOutboundBuffer.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMessage</span><span class="hljs-params">(Object msg, <span class="hljs-type">int</span> size, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.newInstance(msg, size, total(msg), promise);<br>    <span class="hljs-keyword">if</span> (tailEntry == <span class="hljs-literal">null</span>) &#123;<br>        flushedEntry = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> tailEntry;<br>        tail.next = entry;<br>    &#125;<br>    tailEntry = entry;<br>    <span class="hljs-keyword">if</span> (unflushedEntry == <span class="hljs-literal">null</span>) &#123;<br>        unflushedEntry = entry;<br>    &#125;<br><br>    <span class="hljs-comment">// Touch the message to make it easier to debug buffer leaks.</span><br><br>    <span class="hljs-comment">// this save both checking against the ReferenceCounted interface</span><br>    <span class="hljs-comment">// and makes better use of virtual calls vs interface ones</span><br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> AbstractReferenceCountedByteBuf) &#123;<br>        ((AbstractReferenceCountedByteBuf) msg).touch();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ReferenceCountUtil.touch(msg);<br>    &#125;<br><br>    <span class="hljs-comment">// increment pending bytes after adding message to the unflushed arrays.</span><br>    <span class="hljs-comment">// See https://github.com/netty/netty/issues/1619</span><br>    incrementPendingOutboundBytes(entry.pendingSize, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当真正调用了 <code>AbstractUnsafe.flush()</code> 标记消息的flush状态，并<code>flush0()</code> 以后，才会调用<code>doWrite()</code>写到remote socket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span> &#123;<br>    assertEventLoop();<br><br>    <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">outboundBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.outboundBuffer;<br>    <span class="hljs-keyword">if</span> (outboundBuffer == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    outboundBuffer.addFlush();<br>    flush0();<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush0</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (inFlush0) &#123;<br>        <span class="hljs-comment">// Avoid re-entrance</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">outboundBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.outboundBuffer;<br>    <span class="hljs-keyword">if</span> (outboundBuffer == <span class="hljs-literal">null</span> || outboundBuffer.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    inFlush0 = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// Mark all pending write requests as failure if the channel is inactive.</span><br>    <span class="hljs-keyword">if</span> (!isActive()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Check if we need to generate the exception at all.</span><br>            <span class="hljs-keyword">if</span> (!outboundBuffer.isEmpty()) &#123;<br>                <span class="hljs-keyword">if</span> (isOpen()) &#123;<br>                    outboundBuffer.failFlushed(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NotYetConnectedException</span>(), <span class="hljs-literal">true</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Do not trigger channelWritabilityChanged because the channel is closed already.</span><br>                    outboundBuffer.failFlushed(newClosedChannelException(initialCloseCause, <span class="hljs-string">&quot;flush0()&quot;</span>), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            inFlush0 = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        doWrite(outboundBuffer);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleWriteError(t);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        inFlush0 = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-TailContext-组件"><a href="#1-2-TailContext-组件" class="headerlink" title="1.2 TailContext 组件"></a>1.2 TailContext 组件</h2><p>DefaultChannelPipeline的尾节点类型 TailContext。</p><p>在Handler消费一个ReferenceCounted对象时，必须要先调用<code>retain()</code>防止它被意外回收。</p><p>这么做的原因在于，DefaultChannelPipeline的尾节点，默认会释放1次ReferenceCounted对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//TailContext</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            logger.debug(<br>                    <span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +<br>                            <span class="hljs-string">&quot;Please check your pipeline configuration.&quot;</span>, msg);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-DefaultChannelHandlerContext-组件"><a href="#1-3-DefaultChannelHandlerContext-组件" class="headerlink" title="1.3 DefaultChannelHandlerContext 组件"></a>1.3 DefaultChannelHandlerContext 组件</h2><p>默认的HandlerContext对象。</p><p>由于Pipeline的存在，在这条链上的Handler都有上下游的关系。 而有些Handler是 Shareable的，向上下游传播状态信息需要则需要借助 Context。</p><p>万幸的是Netty提供了这样的功能（当然，对于非Shareable的Handler ， Netty更推荐成员内部类的方式，它更直观简洁）。</p><p>使用<code> attr()</code> 在上下文之间传递状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DefaultChannelHandlerContext.java</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Attribute&lt;T&gt; <span class="hljs-title function_">attr</span><span class="hljs-params">(AttributeKey&lt;T&gt; key)</span> &#123;<br>        <span class="hljs-comment">//实际上是 io.netty.channel.Channel.attr() 在工作</span><br>        <span class="hljs-keyword">return</span> channel().attr(key);<br>    &#125;<br></code></pre></td></tr></table></figure><p>context的attr绑定在了 Channel中 ,  io.netty.channel.Channel 继承了DefaultAttributeMap。</p><p>DefaultAttributeMap 是属性存储的实现。</p><h2 id="1-4-ChannelOutboundBuffer"><a href="#1-4-ChannelOutboundBuffer" class="headerlink" title="1.4  ChannelOutboundBuffer"></a>1.4  ChannelOutboundBuffer</h2><h3 id="为什么要设计这个Buffer"><a href="#为什么要设计这个Buffer" class="headerlink" title="为什么要设计这个Buffer"></a>为什么要设计这个Buffer</h3><ol><li><p>首先他是一个buffer，拥有buffer的作用和好处。</p></li><li><p>通过高水位线，控制channel是否不可写。</p><p>当超过高水位线后。 unwritable 标志位将设置非0值。 只有unwritable&#x3D;&#x3D;0时才表示channel可写。</p></li><li><p>触发<code>ChannelWritabilityChanged</code>（通道可写状态改变事件）。</p><p>Netty设计了一个 channel可写数据大小的水位线。</p><p>在ChannelOutboundBuffer中的消息实际还没有被写入socket中。</p><p>当ChannelOutboundBuffer中等待写的数据大小超过水位线以后，将更新 unwritable 的状态。当由0变化为&gt;0时，将会触发<code>ChannelWritabilityChanged</code>事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ChannelOutboundBuffer</span><br>    <br><span class="hljs-comment">//添加消息。但没有flush。主要是在更新 消息Entry的状态。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMessage</span><span class="hljs-params">(Object msg, <span class="hljs-type">int</span> size, ChannelPromise promise)</span> &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.newInstance(msg, size, total(msg), promise);<br>        <span class="hljs-keyword">if</span> (tailEntry == <span class="hljs-literal">null</span>) &#123;<br>            flushedEntry = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> tailEntry;<br>            tail.next = entry;<br>        &#125;<br>        tailEntry = entry;<br>        <span class="hljs-keyword">if</span> (unflushedEntry == <span class="hljs-literal">null</span>) &#123;<br>            unflushedEntry = entry;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> AbstractReferenceCountedByteBuf) &#123;<br>            ((AbstractReferenceCountedByteBuf) msg).touch();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ReferenceCountUtil.touch(msg);<br>        &#125;<br><br>        <span class="hljs-comment">// increment pending bytes after adding message to the unflushed arrays.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/1619</span><br>        incrementPendingOutboundBytes(entry.pendingSize, <span class="hljs-literal">false</span>);<br>    &#125;<br><br><span class="hljs-comment">//增加 还没输出数据的占用的字节数量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementPendingOutboundBytes</span><span class="hljs-params">(<span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> invokeLater)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">newWriteBufferSize</span> <span class="hljs-operator">=</span> TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="hljs-built_in">this</span>, size);<br>        <span class="hljs-comment">//当占用字节数量超过了高水位。</span><br>        <span class="hljs-keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;<br>            <span class="hljs-comment">//更改 unwritable状态位的值</span><br>            setUnwritable(invokeLater);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUnwritable</span><span class="hljs-params">(<span class="hljs-type">boolean</span> invokeLater)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> unwritable;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> oldValue | <span class="hljs-number">1</span>; <span class="hljs-comment">//按位或。 无论原本值是几，最终结果值一定大于等于1</span><br>            <span class="hljs-keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, oldValue, newValue)) &#123;<br>                <span class="hljs-keyword">if</span> (oldValue == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//当由0变为其他值时，触发通道可写性事件。是否稍后执行传播。false表示立即传播。</span><br>                    fireChannelWritabilityChanged(invokeLater);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireChannelWritabilityChanged</span><span class="hljs-params">(<span class="hljs-type">boolean</span> invokeLater)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> channel.pipeline();<br>        <span class="hljs-keyword">if</span> (invokeLater) &#123;<br>            <span class="hljs-comment">//稍后执行，添加到任务队列里。</span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> fireChannelWritabilityChangedTask;<br>            <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>                fireChannelWritabilityChangedTask = task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        pipeline.fireChannelWritabilityChanged();<br>                    &#125;<br>                &#125;;<br>            &#125;<br>            channel.eventLoop().execute(task);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//立即执行（会在addMessage时立即执行）。</span><br>            pipeline.fireChannelWritabilityChanged();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p>通过<code>AbstrachChannel</code>的<code>writeAndFlush()</code> 方法，我们知道期望写出的Messge，先通过pipeline的tail层层传递到 headContext，</p><p>然后通过 ChannelOutboundBuffer，触发高水位线，改变 <code>isWritable()</code>的返回值。</p><p>随后，调用了留给子类实现的抽象方法<code>AbstractChannel.doWrite()</code>  来写出数据。</p><p>下面，我们看一下<code>NioSocketChannel.doWrite()</code>的实现。</p><p>对于Nio来说最终调用写出数据一定是 <code>java.nio.channels.SocketChannel.write()</code>方法。</p><p>TCP的 SO_SNDBUF参数会随着OS而改变，因此Netty为OS进行调整适配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWrite</span><span class="hljs-params">(ChannelOutboundBuffer in)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> javaChannel();<br>    <span class="hljs-comment">//获得自旋锁的次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">writeSpinCount</span> <span class="hljs-operator">=</span> config().getWriteSpinCount();<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (in.isEmpty()) &#123;<br><span class="hljs-comment">//清除 OP_WRITE感兴趣事件</span><br>            clearOpWrite();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Ensure the pending writes are made of ByteBufs only.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxBytesPerGatheringWrite</span> <span class="hljs-operator">=</span> ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();<br>        ByteBuffer[] nioBuffers = in.nioBuffers(<span class="hljs-number">1024</span>, maxBytesPerGatheringWrite);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nioBufferCnt</span> <span class="hljs-operator">=</span> in.nioBufferCount();<br><br>        <span class="hljs-comment">// Always use nioBuffers() to workaround data-corruption.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2761</span><br>        <span class="hljs-keyword">switch</span> (nioBufferCnt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-comment">// We have something else beside ByteBuffers to write so fallback to normal writes.</span><br>                writeSpinCount -= doWrite0(in);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> nioBuffers[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">attemptedBytes</span> <span class="hljs-operator">=</span> buffer.remaining();<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">localWrittenBytes</span> <span class="hljs-operator">=</span> ch.write(buffer);<br>                <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;<br>                    incompleteWrite(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">//调整一次写入的数据量大小</span><br>                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);<br>                <span class="hljs-comment">//将实际写入的数据量从ChannelOutboundBuffer扣除</span><br>                in.removeBytes(localWrittenBytes);<br>                --writeSpinCount;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>: &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">attemptedBytes</span> <span class="hljs-operator">=</span> in.nioBufferSize();<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">localWrittenBytes</span> <span class="hljs-operator">=</span> ch.write(nioBuffers, <span class="hljs-number">0</span>, nioBufferCnt);<br>                <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;<br>                    incompleteWrite(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">// Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.</span><br>                adjustMaxBytesPerGatheringWrite((<span class="hljs-type">int</span>) attemptedBytes, (<span class="hljs-type">int</span>) localWrittenBytes,<br>                        maxBytesPerGatheringWrite);<br>                in.removeBytes(localWrittenBytes);<br>                --writeSpinCount;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (writeSpinCount &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//是否设置 OP_WRITE</span><br>    incompleteWrite(writeSpinCount &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-5-FastThreadLocal"><a href="#1-5-FastThreadLocal" class="headerlink" title="1.5 FastThreadLocal"></a>1.5 FastThreadLocal</h2><p>FastThreadLocal是   ThreadLocal的一个变种。  使用FastThreadLocalThread(继承自Thread，内部有InternalThreadLocalMap)来访问FastThreadLocal时可以提供更好的访问性能 。</p><p>FastThreadLocal为什么快？</p><p>FastThreadLocal 通过索引常量，从数组中读取数据。 而不是使用 hashcode ,hash table 来寻找变量 ，每一个ThreadLocal对象都存储了一个int类型的索引。表示他在InternalThreadLocalMap中的位置。</p><p>虽然比使用hashtable只有轻微的性能优势，  但在频繁访问ThreadLocal的场景下，非常有用。</p><p>为了使用这样的优势（FastThreadLocal），你必须使用 FastThreadLocalThread或它的子类。</p><p>默认情况下，由io.netty.util.concurrent.DefaultThreadFactory创建的线程都是 FastThreadLocalThread 的原因也是如此（获得更高的ThreadLocal性能）。</p><p>reference <a href="https://zhuanlan.zhihu.com/p/662172520">https://zhuanlan.zhihu.com/p/662172520</a></p><p>必须是Thread的子类FastThreadLocalThread才可以使用 FastThreadLocal。</p><p>每一个FastThreadLocal对象都有一个 InternalThreadLocalMap的内部成员，以及 一个 Int类型表示index , 在InternalThreadLocalMap指定索引的位置存放ThreadLocal存储的数据。</p><blockquote><p>详细流程参看 <code>ThreadLocal.get()</code>方法</p></blockquote><p>FastThreadLocal 允许存储null值 ，null代表了一种合法的存储值。</p><h3 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h3><p>FastThreadLocal内部存储映射，是FastThreadLocal的设计核心。</p><p>所有的存储对象，都存放在了 <code>Object[]</code> 数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object[] indexedVariables;<br></code></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h3><p>首先拿到FastThreadLocalThread中的存储结构 InternalThreadLocalMap ，然后在 index位置上，获取数据。</p><p>若该位置为UNSET表示这个ThreadLocal还没有设置值或者值已经被清空。(注意，FastThreadLocal中可以存储一个null ，null可以拥有实际的业务意义。)</p><p>没有设置值，或者值被清空时， 存储的是UNSET对象。 我们可以<code>ThreadLocal.set(null);</code>来表示业务上这个值设置过，并且为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">threadLocalMap</span> <span class="hljs-operator">=</span> InternalThreadLocalMap.get();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> threadLocalMap.indexedVariable(index);<br>    <span class="hljs-keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;<br>        <span class="hljs-keyword">return</span> (V) v;<br>    &#125;<br>    <span class="hljs-comment">//初始化一个默认值。</span><br>    <span class="hljs-keyword">return</span> initialize(threadLocalMap);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll()"></a><code>removeAll()</code></h3><p>移除绑定到当前线程的全部ThreadLocal。</p><p>ThreadLocalMap中有一个slot存储了所有的ThreadLocal。 Slot中存放了一个<code>Set&lt;ThreadLocal&gt;</code> ,在 <code>ThradLocal.set()</code>时都会添加到Set中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">threadLocalMap</span> <span class="hljs-operator">=</span> InternalThreadLocalMap.getIfSet();<br>        <span class="hljs-keyword">if</span> (threadLocalMap == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//从slot中拿到所有的ThreadLocal，依次移除。</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> threadLocalMap.indexedVariable(VARIABLES_TO_REMOVE_INDEX);<br>            <span class="hljs-keyword">if</span> (v != <span class="hljs-literal">null</span> &amp;&amp; v != InternalThreadLocalMap.UNSET) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;<br>                FastThreadLocal&lt;?&gt;[] variablesToRemoveArray =<br>                        variablesToRemove.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocal</span>[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">for</span> (FastThreadLocal&lt;?&gt; tlv: variablesToRemoveArray) &#123;<br>                    tlv.remove(threadLocalMap);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            InternalThreadLocalMap.remove();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从多个角度考量 Unsafe</title>
    <link href="/2024/11/27/2024-11-27-start-with-unsafe/"/>
    <url>/2024/11/27/2024-11-27-start-with-unsafe/</url>
    
    <content type="html"><![CDATA[<p>一开始对Unsafe的认知仅仅局限于CAS操作，随着认知增加 ，实际上：</p><ul><li><p>juc包用它获得offset。</p></li><li><p>nio用Unsafe来判断平台大小端，分配内存。</p></li><li><p>我们甚至可以用它在java平台分配超大内存进行计算。</p></li></ul><span id="more"></span><h1 id="1-Unsafe"><a href="#1-Unsafe" class="headerlink" title="1. Unsafe"></a>1. Unsafe</h1><p>Unsafe是 sun提供的工具<code>sun.misc.Unsafe</code> 。通过它我们可以使用更底层的手段来操作Java内存模型，例如：</p><ul><li><p>保证原子性的交换操作： <code>compareAndSwapObject()</code> ，通常用它来原子的修改状态位，制造一个临界区。</p><p>常见的<code>while(true)</code> 重试使用它。</p></li><li><p>通过加屏障，具有可见的set操作 ： <code>putObjectVolatile</code>  ，通常用它来保证set操作的可见性，和禁止重排。</p></li><li><p>只保证 禁重排，但不立即保证可见性的set操作  ： <code>putOrderedObject</code> 性能更好，在特殊场景下能够优化 putVolatile 。例如 Future中设置状态位（单向的，且状态位含义独立）。</p></li><li><p>分配内存 <code>allocateMemory()</code> , 回收内存<code> reallocateMemory()</code> :  nio用它来判断 平台的大小端。</p></li><li><p>获得数组 baseOffset <code>arrayBaseOffset()</code>  </p><p>获得 数组元素的scale <code>arrayIndexScale()</code> </p><p>访问数组元素公式： 索引为n的元素在数组中的偏移量 indexOffset &#x3D;  base + n* scale</p><p>在j.u.c.a.AtomicIntegerArray 及类似原子数组中使用。</p></li></ul><p>下面是相关代码的举例分析</p><h1 id="2-代码举例"><a href="#2-代码举例" class="headerlink" title="2.  代码举例"></a>2.  代码举例</h1><h2 id="2-1-如何拿到Unsafe"><a href="#2-1-如何拿到Unsafe" class="headerlink" title="2.1 如何拿到Unsafe"></a>2.1 如何拿到Unsafe</h2><p>我们无法直接调用 <code>Unsafe.getUnsafe()</code> 来获得Unsafe ，因此需要使用反射的方式拿到它。</p><p>我们从Netty中copy一个Permit工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Permit</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> (Unsafe) Permit.ReflectiveStaticField(Unsafe.class,<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">ReflectiveStaticField</span><span class="hljs-params">(Class&lt;?&gt; cls,String fieldName)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span>  cls.getDeclaredField(fieldName);<br>            f.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> f.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Field <span class="hljs-title function_">GetField</span><span class="hljs-params">(Class&lt;?&gt; clz,String fieldName)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException&#123;<br><br>        Class&lt;?&gt; c = clz;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (c != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                f = c.getDeclaredField(fieldName);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                c = c.getSuperclass();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (f==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchFieldException</span>(c.getName() + <span class="hljs-string">&quot;::&quot;</span> + fieldName);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-判断平台大小端"><a href="#2-2-判断平台大小端" class="headerlink" title="2.2 判断平台大小端"></a>2.2 判断平台大小端</h2><p>仿照Bits， 我们使用分配内存，再放入一个特殊的long类型，求出他的低地址，然后判断大小端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteOrder nativeByteOrder=<span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> getUnsafe();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> unsafe.allocateMemory(<span class="hljs-number">8</span>); <span class="hljs-comment">//分配一个8byte</span><br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//8个byte， 等于 16个16进制位。</span><br>        unsafe.putLong(l,<span class="hljs-number">0x0102030405060708</span>);  <br>        <span class="hljs-type">byte</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> unsafe.getByte(l);<br>        <span class="hljs-keyword">switch</span> (value)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0x01</span>: &#123; <span class="hljs-comment">//如果低地址是01那么是大端</span><br>                nativeByteOrder = ByteOrder.BIG_ENDIAN;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0x08</span>:&#123; <span class="hljs-comment">//如果低地址是08那么是小端</span><br>                nativeByteOrder = ByteOrder.LITTLE_ENDIAN;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        unsafe.freeMemory(l);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-使用cas模拟临界区"><a href="#2-3-使用cas模拟临界区" class="headerlink" title="2.3 使用cas模拟临界区"></a>2.3 使用cas模拟临界区</h2><p>对于一个volatile变量，如果你只想检查它的状态做判断，那么无需使用原子性。</p><p>但是如果想模拟一个临界区，那么必须使用原子的修改操作，来修改状态位。</p><p>它通常是用一个 while死循环来模拟，这样的公式代码在juc中随处可见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们必须给state规定几个特殊值，表示对象处于不同的状态。 这一步非常重要。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br><br><span class="hljs-comment">//我们还必须拿到 state在 class的offset;  通过 Unsafe.objectFieldOffset()方法拿到</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> STATE_OFFSET;<br><br><br><span class="hljs-comment">//按照序号解读代码，更容易懂。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i ;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        <span class="hljs-comment">//1.读一次state的值到操作数栈(本地),这个值可能不是最新的，但没关系。若不为最新CAS操作一定会失败，然后走for循环再次尝试</span><br>      i=state;<br>        A:<br>        <span class="hljs-comment">//2.这里我们通过原子操作，保证了临界区内有且只有1个线程操作,让this对象的状态由0过渡到-1</span><br>        <span class="hljs-comment">//2.代码块中的 do something就是过渡过程中，执行的逻辑。</span><br>        <span class="hljs-keyword">if</span>(unsafe.compareAndSetInt(<span class="hljs-built_in">this</span>,STATE_OFFSET,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-comment">//3. safe to do something start</span><br>            <br>            <span class="hljs-comment">//4. 这里是处理具体业务逻辑的地方。这里算作临界区内部，这里不用担心任何并发，可以随意执行”非原子操作“</span><br>            <br>            <span class="hljs-comment">//5.safe to do something ending</span><br>            <br>            state=<span class="hljs-number">1</span>; <span class="hljs-comment">//6.处理成功以后我们可以安全的，不用任何修饰的修改state的值</span><br>            <span class="hljs-comment">//6.这里我修改为1,没有什么特别的含义。仅仅表示一种独特的状态。你可以（根据业务需要）将state修改为任意值。</span><br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//7. 处理成功以后，我们就要退出死循环了。这里可以是break（然后处理其他逻辑）。</span><br>            <span class="hljs-comment">//7. 也可以直接return（根据需要）</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是： 上面<a href="https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782?utm_source=glcblog&spm=1001.2101.3001.7020">模板</a>代码”可能”存在死循环状态 。</p><p>如果state变为1以后，如果【后续】没有任何其他线程将state其变为0，那么将会死循环。</p><blockquote><p>这个 “可能”想表达的含义是，这么写代码 , 没有语法错误，并且能正常执行，但它可能不符合业务需求。</p></blockquote><h2 id="2-4-顺序put优化volatile"><a href="#2-4-顺序put优化volatile" class="headerlink" title="2.4 顺序put优化volatile"></a>2.4 顺序put优化volatile</h2><p>在FutureTask中， state 过渡到终止状态以后，不会再发生改变。并且每一种状态都是独一无二的。</p><p>因此，可以使用 <code>putOrderedInte</code>  来优化 <code>putIntVolatile()</code> : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FutureTask.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// in case call to interrupt throws exception</span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                    t.interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// final state</span><br>                <span class="hljs-comment">//有且只能有一个线程能够竞争到   INTERRUPTING 或 CANCELLED</span><br>                <span class="hljs-comment">//因此晚一点儿让其他线程看到  从INTERRUPTING  --&gt;  INTERRUPTED 是没问题的。</span><br>                <span class="hljs-comment">//因为其他人没有竞争到INTERRUPTING 也就不会进行其他修改状态的操作</span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        finishCompletion();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-java中的大内存"><a href="#3-java中的大内存" class="headerlink" title="3. java中的大内存"></a>3. java中的大内存</h1><p>在java中申请数组，数组最大长度必须小于等于 <code>Integer.MAX_VALUE</code></p><p>在考虑到内存充裕的情况下，常规手段java能申请到多大的内存空间处理数据？</p><ul><li>对于  long[] 来说， 最多能够申请到 <code>long[Integer.MAX_VALUE]</code>  约等于16G的数据  8B * (2^31-1) &#x2F;1024 &#x2F;1024&#x2F;1024  &#x3D; 15.99GB</li><li>对于  int[] 来说， 最多能够申请到 <code>iny[Integer.MAX_VALUE]</code>  约等于8G的数据  4B * (2^31-1) &#x2F;1024 &#x2F;1024&#x2F;1024  &#x3D; 7.99GB</li><li>对于 byte[] 来说，最多能够申请到  <code>byte[]</code> 与等于1.9GB      1B * (2^31-1) &#x2F;1024 &#x2F;1024&#x2F;1024  &#x3D; 1.99GB</li></ul><p>也就是说，我们可以通过  “使用<code>long[]</code>申请到超大的内存，然后把它看作byte来处理的方式” 来变相扩大byte数组的分配空间。</p><p>在java中想要这样做，需要借助Unsafe 访问数组 : </p><h1 id="4-一些其他的思考"><a href="#4-一些其他的思考" class="headerlink" title="4. 一些其他的思考"></a>4. 一些其他的思考</h1><h2 id="4-1-什么场景下使用原子数组"><a href="#4-1-什么场景下使用原子数组" class="headerlink" title="4.1 什么场景下使用原子数组"></a>4.1 什么场景下使用原子数组</h2><p>AtomicIntegerArray保证了get操作的可见性，意味着对数组元素变化是敏感的。</p><p>如果某些业务， 严格依赖数组元素当前状态下的值，可能会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AtomicIntegerArray.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> getRaw(checkedByteOffset(i));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRaw</span><span class="hljs-params">(<span class="hljs-type">long</span> offset)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getIntVolatile(array, offset);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><p><a href="https://segmentfault.com/a/1190000000441670">https://segmentfault.com/a/1190000000441670</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis 参数名称解析器</title>
    <link href="/2024/11/25/2024-11-25-mybatis-param-name-resolver/"/>
    <url>/2024/11/25/2024-11-25-mybatis-param-name-resolver/</url>
    
    <content type="html"><![CDATA[<p>一直都比较好奇Mybatis的参数名解析(@Param)  是怎么做的。虽然大致也能猜到是反射拿到注解信息。</p><p>今天从debug源码出发，开始分析是哪些类完成的命名解析。</p><span id="more"></span><h1 id="1-Param"><a href="#1-Param" class="headerlink" title="1.@Param"></a>1.@Param</h1><p>mybatis支持使用@param 来为Mapper方法的参数起别名:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//fooMapper.java</span><br><br>List&lt;TCtInfoManagerInfo&gt; <span class="hljs-title function_">getTCtInfoManagerInfoByProjectSubId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span>String projectSubId,</span><br><span class="hljs-params">                                                             <span class="hljs-meta">@Param(&quot;foo&quot;)</span>String foo,</span><br><span class="hljs-params">                                                             <span class="hljs-meta">@Param(&quot;foo1&quot;)</span>String foo1)</span>;<br></code></pre></td></tr></table></figure><p>并在xml中进行调用： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTCtInfoManagerInfoByProjectSubId&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.bjdv.es.web.service.dto.TCtInfoManagerInfo&quot;</span>&gt;</span><br>SELECT *<br>FROM `project_sub_team` A LEFT JOIN `t_ct_info` B ON A.info_id = B.id <br>           LEFT JOIN `sys_user` C ON C.id = B.manager<br>WHERE A.sub_id = #&#123;id&#125; and A.foo = #&#123;foo&#125; and A.foo1 = &#123;foo1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们称这种为 参数名（ParamName）。</p><p>事实上每个参数都有一个默认名，我们可以这样使用: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//fooMapper.java</span><br><br>List&lt;TCtInfoManagerInfo&gt; <span class="hljs-title function_">getTCtInfoManagerInfoByProjectSubId</span><span class="hljs-params">(String projectSubId,</span><br><span class="hljs-params">                                                             String foo,</span><br><span class="hljs-params">                                                             String foo1)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTCtInfoManagerInfoByProjectSubId&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.bjdv.es.web.service.dto.TCtInfoManagerInfo&quot;</span>&gt;</span><br>SELECT *<br>FROM `project_sub_team` A LEFT JOIN `t_ct_info` B ON A.info_id = B.id <br>           LEFT JOIN `sys_user` C ON C.id = B.manager<br>WHERE A.sub_id = #&#123;param1&#125; and A.foo = #&#123;param2&#125; and A.foo1 = &#123;param3&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mybatis在解析命名的时候，为没有命名的参数，存入了默认命名。它取决于方法中参数的顺序，依次为：</p><p>param1 param2 param3…</p><p>并且，这个名称是冗余的名称，即使定义了 param ，我们也可以使用。</p><h1 id="2-参数名是如何解析的？"><a href="#2-参数名是如何解析的？" class="headerlink" title="2.参数名是如何解析的？"></a>2.参数名是如何解析的？</h1><p>Mybatis通过<code>org.apache.ibatis.reflection.ParamNameResolver</code>完成参数解析的。</p><p>名称规则是：</p><ul><li>如果参数使用 Param(value) 修饰，那么参数的名称为value 。</li><li>如果没有使用参数， 则使用参数的索引</li><li>对于特殊参数（RowBounds 或 ResultHandler ），不会算作param (也就是无法通过 param+index 来引用他们)</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;M&quot;)</span> <span class="hljs-type">int</span> a, <span class="hljs-meta">@Param(&quot;N&quot;)</span> <span class="hljs-type">int</span> b)</span>;  <span class="hljs-comment">//  --&gt;  (0, &quot;M&quot;), (1, &quot;N&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>    <span class="hljs-comment">//  --&gt;  (0, &quot;0&quot;), (1, &quot;1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, RowBounds rb, <span class="hljs-type">int</span> b)</span> <span class="hljs-comment">//    --&gt; (0, &quot;0&quot;), (2, &quot;1&quot;)</span><br></code></pre></td></tr></table></figure><p>每一个MapperMethod ，都会创建一个参数名解析器（ParamNameResolver），在它的构造器中，完成了 </p><p>“ 参数在方法中的索引-&gt; 参数名”的解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ParamNameResolver</span><span class="hljs-params">(Configuration config, Method method)</span> &#123;<br>  <span class="hljs-built_in">this</span>.useActualParamName = config.isUseActualParamName();<span class="hljs-comment">//默认true，使用参数真实的名称</span><br>  <span class="hljs-keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();<span class="hljs-comment">//每个参数的类型</span><br>  <span class="hljs-keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();<span class="hljs-comment">//每个参数的注解</span><br>  <span class="hljs-keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">paramCount</span> <span class="hljs-operator">=</span> paramAnnotations.length;<br>  <span class="hljs-comment">// 从每个参数中获得名称</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">paramIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;<br>    <span class="hljs-keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;<span class="hljs-comment">//如果是特殊参数，则跳过</span><br>      <span class="hljs-comment">// skip special parameters</span><br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;<span class="hljs-comment">//这里可以看到遍历了每个参数注解</span><br>      <span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> Param) &#123;<br>        hasParamAnnotation = <span class="hljs-literal">true</span>;<br>        name = ((Param) annotation).value();<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// @Param was not specified.</span><br>      <span class="hljs-keyword">if</span> (useActualParamName) &#123;<br>        name = getActualParamName(method, paramIndex);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span><br>        <span class="hljs-comment">// gcode issue #71</span><br>        name = String.valueOf(map.size());<span class="hljs-comment">//参数没有声明名字，用map.size()代替</span><br>      &#125;<br>    &#125;<br>    map.put(paramIndex, name);<br>  &#125;<br>  names = Collections.unmodifiableSortedMap(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>随后，在获取参数名的时候，会使用 <code>GENERIC_NAME_PREFIX</code> 静态变量最为前缀，拼接索引+1 。</p><p>而<code>GENERIC_NAME_PREFIX</code> 的默认值为 <code>param</code> ，由此出现了默认名 <code>param1</code> <code>param2</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ParameterNameResolver.java</span><br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getNamedParams</span><span class="hljs-params">(Object[] args)</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">paramCount</span> <span class="hljs-operator">=</span> names.size();<br>  <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span> || paramCount == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">//没有 Param注解，且 只有1个参数的情况 ，返回参数中的第一个key。  </span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> args[names.firstKey()];<span class="hljs-comment">//值总是为0</span><br>      <span class="hljs-comment">//将参数返回为一个ParamMap(ibatis内部的Map，重写了get方法，当get不到key时抛出异常)  </span><br>      <span class="hljs-comment">// 或 返回null</span><br>    <span class="hljs-keyword">return</span> wrapToMapIfCollection(value, useActualParamName ? names.get(<span class="hljs-number">0</span>) : <span class="hljs-literal">null</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果是多参数，则执行这个分支</span><br>    <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParamMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;<br>        <span class="hljs-comment">//从解析的names Map拷贝key 和value</span><br>      param.put(entry.getValue(), args[entry.getKey()]); <br>        <span class="hljs-comment">//添加通用的参数名称 （例如 param1, param2 ,param3），</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">genericParamName</span> <span class="hljs-operator">=</span> GENERIC_NAME_PREFIX + (i + <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// 避免不会重写 `@Param(&quot;param1&quot;)`的情况</span><br>      <span class="hljs-keyword">if</span> (!names.containsValue(genericParamName)) &#123; <span class="hljs-comment">//注意到是冗余的，只有出现冲突的时候，才不会放入</span><br>        param.put(genericParamName, args[entry.getKey()]);<br>      &#125;<br>      i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> param;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并且，这个方法将 List 、Array的参数都转换为了Map</p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
